struct TrottingInfo {
        // Defaults
        Rot *body_orientation;
        Point default_leg_position[4];
        Point default_height;
        Point raise_height;
        Point push_height;

        // Movement Request
        double *dx;
        double *dy;
        double *dyaw;
        Frame frame; // Frame that the movement request was provided in

        // State
        int state;
        Timer timer;
        bool begin_state;
        bool leg_is_swinging[4];

        TrottingInfo() {}

        TrottingInfo(double *x, double *y, double *yaw, Rot *body_orientation_ref) {
            Point COM = Point(0, 0, 0);
            default_leg_position[0] = Point( LENGTH2,  WIDTH2, 0) - COM; // All these need to be variablized
            default_leg_position[1] = Point(-LENGTH2,  WIDTH2, 0) - COM;
            default_leg_position[2] = Point(-LENGTH2, -WIDTH2, 0) - COM;
            default_leg_position[3] = Point( LENGTH2, -WIDTH2, 0) - COM;

            leg_is_swinging[0] = false;
            leg_is_swinging[1] = true;
            leg_is_swinging[2] = false;
            leg_is_swinging[3] = true;

            dy = y;
            dx = x;
            dyaw = yaw;
            body_orientation = body_orientation_ref;

            default_height = Point(0, 0, 120);
            raise_height = Point(0, 0, 15);
            push_height = Point(0, 0, 10);

            frame = Frame::BODY;
            state = 0;
            begin_state = true;
        }

        Rot getBodyYaw() {
            return Rot(0, 0, body_orientation->z);
        }

        // Desired position in ground frame
        Point getRequestedLegPosition(int i) {
            Rot r = getRequestedRot() + getBodyYaw();
            Point dp = getRequestedTrans();
            if (frame == Frame::BODY) {
                dp /= r;
            }
            return default_leg_position[i] / r + dp;
        }

        // Unmoved position in ground frame
        Point getDefaultLegPosition(int i) {
            return default_leg_position[i] / Rot(0, 0, body_orientation->z);
        }

        // Amount to rotate by
        Rot getRequestedRot() {
            return Rot(0, 0, *dyaw);
        }

        Point getRequestedTrans() {
            return Point(*dx, *dy, 0);
        }

        bool legIsSwinging(int i) {
            return leg_is_swinging[i];
        }

        void switchPhase() {
            for (int i = 0; i < NUM_LEGS; i++) {
                leg_is_swinging[i] = !leg_is_swinging[i];
            }
        }
    };

    // Trotting
    TrottingInfo trot_info;

    void beginTrot(double *x, double *y, double *yaw) {
        trot_info = TrottingInfo(x, y, yaw, &body_orientation);
        trot_info.timer.reset();
    }

    void setTrotFrame(Frame frame) {
        trot_info.frame = frame;
    }

    void trot() {

        //Serial.print("desired orient: "); desired_orientation.print();

        switch (trot_info.state) {
            case 0: {// Pull body to center, Raise legs up
                if (trot_info.begin_state) {
                    // Serial.println("State 0: Raise Leg");
                    int period = (75);
                    // Raise 2 feet up
                    for (int i = 0; i < NUM_LEGS; i++) {
                        if (trot_info.legIsSwinging(i)) {
                            leg[i]->setState(CoordinationState::FIXED);
                            leg[i]->setToPositionFromCentroid(trot_info.getDefaultLegPosition(i) + trot_info.raise_height, 
                                                              Frame::GROUND, period*0.99);
                        } else {
                            leg[i]->setState(CoordinationState::ANCHORED);
                        }
                    }
                    // Pull body
                    Rot desired_orientation = body_orientation * (0.9);
                    desired_orientation.z = body_orientation.z;
                    setFromCentroid(desired_orientation, 
                                    trot_info.default_height + trot_info.push_height * 0.5, 
                                    Frame::GROUND, period * 0.99); // move dog body up a bit
                    
                    trot_info.timer.reset(period);
                    trot_info.begin_state = false;
                    break;
                }
                // Maintain Balance...not ready yet

                // Finished. Switch state.
                if (trot_info.timer.timeOut()) {
                    trot_info.state = 1;
                    trot_info.begin_state = true;
                } else {
                    break;
                }
            }
            case 1: {// Kick legs out, push body forward; maintain balance
                if (trot_info.begin_state) {
                    // Serial.println("State 1: Kick Leg");
                    int period = (75);

                    // Kick 2 feet out
                    for (int i = 0; i < NUM_LEGS; i++) {
                        if (trot_info.legIsSwinging(i)) {
                            leg[i]->setToPositionFromCentroid(trot_info.getRequestedLegPosition(i) + trot_info.raise_height, 
                                                              Frame::GROUND, period * 0.99);
                        }
                    }
                    // Push Body Forward and up
                    Rot desired_orientation = body_orientation * (0.9);
                    desired_orientation.z = body_orientation.z;
                    setFromCentroid(desired_orientation+ trot_info.getRequestedRot(), 
                                    trot_info.default_height + trot_info.getRequestedTrans() * (0.7) + trot_info.push_height, 
                                    Frame::GROUND, period * 0.99);
                    
                    trot_info.timer.reset(period);
                    trot_info.begin_state = false;
                    break;
                }
               // maintain balance

                // Finished. Switch state.
                if (trot_info.timer.timeOut()) {
                    trot_info.state = 2;
                    trot_info.begin_state = true;
                } else {
                    break;
                }
            }
            case 2: {// Setting feet down
                if (trot_info.begin_state) {
                    // Serial.println("State 2: Return Leg");
                    int period = (100);

                    // Place feet on floor
                    for (int i = 0; i < NUM_LEGS; i++) {
                        if (trot_info.legIsSwinging(i)) {
                            // leg[i]->getCurrentFootPositionFromBody(Frame::BODY).print();
                            // if (leg[i]->getCurrentFootPositionFromBody(Frame::BODY).z < -120) {
                            //     Serial.println("hi");
                            //     leg[i]->setState(CoordinationState::FLOATING);
                            //     leg[i]->setToPositionFromBody(trot_info.getRequestedLegPosition(i) - trot_info.default_height*0.8, Frame::GROUND, period*0.99);
                            //     // leg[i]->setToPositionFromCentroid(trot_info.getRequestedLegPosition(i) + trot_info.push_height * (0.3), 
                            //                                       // Frame::GROUND, period * 0.99);
                            // } else {
                                leg[i]->setToPositionFromCentroid(trot_info.getRequestedLegPosition(i), 
                                                                  Frame::GROUND, period * 0.99);
                            // }
                                                        // leg[i]->setState(CoordinationState::FLOATING);
                            // leg[i]->setToPositionFromBody(trot_info.getRequestedLegPosition(i) - trot_info.default_height, Frame::GROUND, period*0.99);

                        }
                    }
                    // Set Body Down
                    Rot desired_orientation = body_orientation * (0.9);
                    desired_orientation.z = body_orientation.z;
                    setFromCentroid(desired_orientation + trot_info.getRequestedRot() * (0.9),  
                                    trot_info.default_height + trot_info.getRequestedTrans(), 
                                    Frame::GROUND, period * 0.99);
                    
                    trot_info.timer.reset(period);
                    trot_info.begin_state = false;
                    break;
                }

                // Check if legs have hit the ground. Also maintain balance.
                bool legs_hit_ground = false;


                // Legs have completed trajectory. Switch to other legs
                if (trot_info.timer.timeOut() || legs_hit_ground) {
                    trot_info.state = 3;
                    trot_info.begin_state = true;
                    trot_info.switchPhase();
                } else {
                    break;
                }
            }
            case 3: {// Setting feet down
                if (trot_info.begin_state) {
                    // Serial.println("State 3: Reanchor");
                    int period = (50);

                    // Place feet on floor
                    for (int i = 0; i < NUM_LEGS; i++) {
                        leg[i]->setState(CoordinationState::ANCHORED);
                    }
                    // Set Body Down
                    Rot desired_orientation = body_orientation * (0.5);
                    desired_orientation.z = body_orientation.z;
                    setFromCentroid(desired_orientation,  
                                    trot_info.default_height, 
                                    Frame::GROUND, period * 0.99);
                    trot_info.timer.reset(period);
                    trot_info.begin_state = false;
                    break;
                }

                // Legs have completed trajectory. Switch to other legs
                if (trot_info.timer.timeOut()) {
                    trot_info.state = 0;
                    trot_info.begin_state = true;
                } else {
                    break;
                }
            }
        }

        operate();
    }